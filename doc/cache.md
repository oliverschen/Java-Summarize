# 🐣分布式缓存

### 数据分类

- 静态数据：一般不变，类似于字典表
-  准静态数据：变化频率很低，部门结构设置，全国行政区划数据等 
- 中间状态数据：一些计算的可复用中间数据，变量副本，配置中心的本地副本
- 热数据：使用频率高 
- 读写比较大：读的频率 >> 写的频率

### 缓存加载时机

- 启动全量加载：全局有效，使用简单
- 懒加载 
   - **同步使用加载**
      - 先看缓存是否有数据，没有的话从数据库读取
      - 读取的数据，先放到内存，然后返回给调用方 
  - **延迟异步加载**
    - 从缓存获取数据，不管是否为空直接返回
      - 策略1异步）如果为空，则发起一个异步加载的线程，负责加载数据 
      - 策略2解耦）异步线程负责维护缓存的数据，定期或根据条件触发更新

### 常见问题

#### 缓存击穿

某个 KEY 失效的时候，正好有大量并发请求访问这个 KEY。 

##### 解决办法

1. KEY 的更新操作添加**全局互斥锁**。
2. 完全以缓存为准，使用**延迟异步加载**的策略2，这样就不会触发更新。

#### 缓存穿透

大量并发查询不存在的 KEY，导致都直接将压力透传到数据库。 

##### 解决办法

1. **缓存空值**的KEY，这样第一次不存在也会被加载会记录，下次拿到有这个KEY。
2. Bloom 过滤或 **RoaringBitmap** 判断 KEY 是否存在。 
3. 完全以缓存为准，使用**延迟异步加载**的策略2，这样就不会触发更新。

#### 缓存雪崩

当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到数据库，导致数 据库压力过大升值宕机。 

##### 解决办法

1. 更新策略在**时间**上做到比较**均匀**。 

2. 使用的**热数据**尽量**分散**到不同的机器上。 

3. 多台机器做主从复制或者多副本，实现**高可用**。 

4. 实现**熔断限流**机制，对系统进行负载能力控制。

### Redis

#### 使用场景

1. 业务数据缓存
2. 业务数据处理「排行榜，幂等校验」
3. 全局一致性计数「流控计数，库存，全局ID，抢红包」
4. 高效统计计数「ID bitmap 去重」
5. 发布订阅功能「简易 MQ」
6. 分布式锁

#### 过期策略

##### 被动删除

当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key

##### 主动删除

由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批**已过期**的key

##### 内存不足

当前已用内存超过 maxmemory 限定时，触发**主动清理策略**

##### 主动清除策略

设置了过期时间：

1. volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。
2. volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。
3. volatile-lru：会使用 LRU 算法筛选设置了过期时间的键值对删除。
4. volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除。

针对所有 key：

1. allkeys-random：从所有键值对中随机选择并删除数据。
2. allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。
3. allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。

不处理：

noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息"(error) OOM command not allowed when used memory"，此时Redis只响应读操作。

### 组件

#### Redisson

基于Netty NIO，API线程安全。 

亮点：大量丰富的分布式功能特性，比如JUC的线程安全集合和工具的分布式版本，分布式的基本数据类型和锁等。

#### Hazelcast

内存网格， Hazelcast IMGD(in-memory data grid) 是一个标准的内存网格系统；它具有以下的一 些基本特性： 

1. 分布式的：数据按照某种策略尽可能均匀的分布在集群的所有节点上。
2. 高可用：集群的每个节点都是 active 模式，可以提供业务查询和数据修改事务；部 分节点不可用，集群依然可以提供业务服务。 
3. 可扩展的：能按照业务需求增加或者减少服务节点。 
4. 面向对象的：数据模型是面向对象和非关系型的。在 java 语言应用程序中引入 hazelcast client api是相当简单的。 
5. 低延迟：基于内存的，可以使用堆外内存。

### 总结图

<img src="https://github.com/oliverschen/Java-Summarize/blob/main/images/cache.png" style="zoom:50%" />

