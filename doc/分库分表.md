## 🎯分库分表

### 单机MySql问题

随着数据量的增大，读写并发的增加，系统可用性要求的提升，单机 MySQL 面临：

1. 容量有限，难以扩容

2. 读写压力，QPS 过大，特别是分析类需求会影响到业务事务

3. 可用性不足，宕机问题

### MySql主从复制

#### 原理

1. 主库写 binlog

2. 从库 relay log

#### binlog形式

##### row

日志中会记录成每一行数据被修改的形式，然后在 slave 端再对相同的数据进行修改，只记录要修改的数据，只有 value，不会有sql多表关联的情况。

**优点: ** 在row模式下，bin-log 中可以不记录执行的 sql 语句的上下文相关的信息，仅仅只需要记录那一条记录被修改了，修改成什么样了，所以 row 的日志内容会非常清楚的记录下每一行数据修改的细节，非常容易理解。而且不会出现某些特定情况下的存储过程和 function，以及trigger 的调用无法被正确复制问题。

**缺点: ** 在 row 模式下，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。

##### statement

每一条修改数据的 sql 都会记录到 master 的 binlog 中，slave 在复制的时候 sql 进程会解析成和原来 master 端执行多相同的 sql 再执行。
**优点**：首先解决了 row 模式的缺点，不需要记录每一行数据的变化，减少了 binlog 日志量，节省了 I/O 以及存储资源，提高性能。它只记录在 master 上所执行的语句的细节以及执行语句的上下文信息。
**缺点**：由于它是记录的执行语句，所以为了让这些语句在 slave 端也能正确执行，那么他还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，以保证所有语句在 slave 端被执行的时候能够得到和在 master 端执行时候相同的结果。另外，由于 mysql 现在发展比较快，很多的新功能不断的加入，使 mysql 的复制遇到了不小的挑战，自然复制的时候涉及到越复杂的内容会存在一些问题。

##### Mixed

前两种模式的结合。在 Mixed 模式下，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 statement 和 row 之间选择一种。新版本中的 statment 还是和以前一样，仅仅记录执行的语句。而新版本的 MySQL 中对 row 模式也被做了优化，并不是所有的修改都会以 row 模式来记录，比如遇到表结构变更的时候就会以 statement 模式来记录，如果 SQL 语句确实就是 update 或者 delete 等修改数据的语句，那么还是会记录所有行的变更。

#### 复制基本过程

1. Slave 通过 IO 进程连接上 Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容。
2. Master 接收到来自 Slave 的 IO 进程的请求后，负责复制的 IO 进程会根据请求信息读取日志指定位置之后的日志信息，返回给 Slave 的IO 进程。返回信息中除了日志所包含的信息外，还包括本次返回的信息已经到 Master 端的 `bin-log` 文件的名称以及它的位置。
3. Slave 的 IO 进程接收到信息后，将接收到的日志内容依次添加到 Slave 端的 `relay-log` 文件的最末端，并将读取到的 Master 端的 `bin-log` 的文件名和位置记录到 master-info 文件中，下一次读取时能指定 `bin-log` 位置增量同步。
4. Slave 的 Sql 进程检测到 `relay-log` 中新增加了内容后，会马上解析 `relay-log`  的内容成为在 Master 端真实执行时候的那些可执行的内容，并在自身执行。

### MySQL高可用

#### 原因

1. 读写分离，提升读的处理能力

2. 故障转移，提供 failover 能力

3. 加上业务侧连接池的心跳重试，实现断线重连，业务不间断，降低 RTO 和 RPO。

#### 策略

##### MHA

MHA（Master High Availability）目前在 MySQL 高可用方面是一个相对成熟的解决方案，它由日本 DeNA 公司的 youshimaton（现就职于 Facebook 公司）开发，是一套优秀的作为 MySQL 高可用性环境下故障切换和主从提升的高可用软件。基于 Perl 语言开发，一般能在30s内实现主从切换。切换时，直接通过 SSH 复制主节点的日志。

##### MGR

MGR（MySQL Group Replication）MySQL官方于2016年12月推出的一个全新的高可用与高扩展的解决方案,提供了高可用、高扩展、高可靠的MySQL集群服务。

##### MySQL Cluster

MySQL Cluster 是 MySQL 适合于分布式计算环境的高实用、高冗余版本。它采用了NDB Cluster 存储引擎，允许在1个 Cluster 中运行多个MySQL服务器。该技术允许在无共享的系统中部署“内存中”数据库的 Cluster 。通过无共享体系结构，系统能够使用廉价的硬件，而且对软硬件无特殊要求。此外，由于每个组件有自己的内存和磁盘，不存在单点故障。

##### Orchestrator

go 编写的 MySQL 高可用性和复制拓扑管理工具，支持复制拓扑结构的调整，自动故障转移和手动主从切换等。并提供Web界面展示 MySQL复制的拓扑关系及状态，通过 Web 可更改 MySQL 实例的复制关系和部分配置信息，同时也提供命令行和 api 接口，方便运维管理。相对比MHA来看最重要的是解决了管理节点的单点问题，其通过raft协议保证本身的高可用。

###### 特点

1. 自动发现MySQL的复制拓扑，并且在web上展示。
2. 重构复制关系，可以在web进行拖图来进行复制关系变更。
3. 检测主异常，并可以自动或手动恢复，通过Hooks进行自定义脚本。

4. 支持命令行和web界面管理复制。

### 分库分表

#### 垂直拆分

垂直拆分（**拆库**）：将一个数据库，拆分成多个提供不同业务数据处理能力的数据库。

垂直拆分（**拆表**）：如果单表数据量过大，还可能需要对单表进行拆分。

##### 优点

1. 单库（单表）变小，便于管理和维护
2. 对性能和容量有提升作用
3. 改造后，系统和数据复杂度降低
4. 可以作为微服务改造的基础

##### 缺点

1. 库变多，管理变复杂
2. 对业务系统有较强的侵入性
3. 改造过程复杂，容易出故障
4. 拆分到一定程度就无法继续拆分

##### 一般做法

1. 梳理清楚拆分范围和影响范围
2. 检查评估和重新影响到的服务
3. 准备新的数据库集群复制数据
4. 修改系统配置并发布新版上线

#### 水平拆分

水平拆分（按主键分库分表）：水平拆分就是直接对数据进行分片，有分库和分表两个具体方式，但是都只是降低单个节点数据量，但不改变数据本身的结构。这样对业务系统本身的代码逻辑来说，就不需要做特别大的改动，甚至可以基于一些中间件做到透明。

##### 优点

1. 解决容量问题
2. 比垂直拆分对系统影响小
3. 部分提升性能和稳定性

##### 缺点

1. 集群规模大，管理复杂
2. 复杂 SQL 支持问题（业务侵入性、性能）
3. 数据迁移问题
4. 一致性问题

#### shardingsphere

###### **框架 ShardingSphere-JDBC**

直接在业务代码使用。支持常见的数据库和 JDBC。Java only。

###### **中间件 ShardingSphere-Proxy**

作为中间件，独立部署，对业务端透明。目前支持 MySQL 和 PostgreSQL。任何语言平台的系统都可以接入，可以使用 mysql 命令或者 IDE 操作。对业务系统侵入性小。

#### 数据迁移

##### 全量

全量数据导出和导入

1. 业务系统停机
2. 数据库迁移，校验一致性
3. 然后业务系统升级，接入新数据库。

直接复制的话，可以 dump 后全量导入（如果是）异构数据，需要用程序来处理

##### 增量

依赖于数据本身的时间戳

1. 先同步数据到最近的某个时间戳
2. 然后在发布升级时停机维护，
3. 再同步最后一段时间（通常是一天）的变化数据。
4. 最后升级业务系统，接入新数据库。

##### binlog+全量+增量

通过主库或者从库的 binlog 来解析和重新构造数据，实现复制。一般需要中间件等工具的支持。可以实现多线程，断点续传，全量历史和增量数据同步。继而可以做到：

1. 实现自定义复杂异构数据结构；

2. 实现自动扩容和缩容，比如分库分表到单库单表，单库单表到分库分表，分4个库表到分64个库表。

### 分布式事务

分布式条件下，**多个节点**操作的整体事务**一致性**。 特别是在微服务场景下，业务A和业务B关联，事务A成功，事务B失败，由于跨系统，就会导致不被感知。此时从整体来看，数据是不一致的。 

#### 分布式一致性

1. 理想状态：直接想单机数据库事务一样，多个数据库自动通过某种协调机制，实现了跨数据库节点的一致性。 使用场景：要求严格的一致性，比如金融交易类业务。 
2. Z 使用场景：准实时或非实时的处理，比如T+1的各类操作，或者电商类操作。

##### XA

强一致的思路，就有了基于数据库本身支持的协议，XA 分布式事务。 XA 整体设计思路可以概括为，如何在现有事务模型上微调扩展，实现分布式事务。

###### 组件

AP：是指应用程序。

RM是资源管理器，事务的参与者，通常是数据库，比如MySQL Server。一个分布式事务通常涉及多个资源管理器。

TM：是事务管理器，创建分布式事务并协调分布式事务中的各个子事务的执行和状态。子事务是指分布式事务中在RM上执行的具体操作

**两阶段提交 (Two-Phase Commit, 简称2PC) ** ,为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法。分布式事务通常采用 2PC，二阶段提交的算法思路可以概括为：

参与者（RM）将操作成败通知协调者（TM），再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。

###### 主流框架

主流支持 XA 的框架，比较推荐 `Atomikos` 和 `narayana`

##### BASE柔性事务

> 本地事务 ==> XA(2PC)  ==> BASE 

如果将实现了 ACID 的事务要素的事务称为刚性事务的话，那么基于 BASE 事务要素的事务则称 为柔性事务。 BASE 是基本可用、柔性状态和最终一致性这三个要素的缩写。柔性事务的理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面。通过放宽对强一致性要求， 来换取系统吞吐量的提升。

**基本可用（Basically Available）** 保证分布式事务参与方不一定同时在线。 

**柔性状态（Soft state）**则允许系统状态更新有一定的延时，这个延时对客户来说不一定能够 察觉。

**最终一致性（Eventually consistent）** 通常是通过消息传递的方式保证系统的最终一致性。 在 ACID 事务中对隔离性的要求很高，在事执行过程中，必须将所有的资源锁定。 

###### TCC

BASE 柔性事务 TCC，TCC 模式即将每个服务业务操作分为两个阶段，第一个阶段检查并预留相关资源，第二阶段根据所有服务业务的 `Try`状态来操作，如果都成功，则进行 `Confirm` 操作，如果任意一个 `Try` 发生 **错误** ，则全部 `Cancel` 。 TCC 使用要求就是业务接口都必须实现三段逻辑：

1. 准备操作 Try：完成所有业务检查，预留必须的业务资源。 
2. 确认操作 Confirm：真正执行的业务逻辑，不做任何业务检查，只使用 Try 阶段预留的业务资源。因此， 只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务能且 只能成功一次。 
3. 取消操作 Cancel：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。

TCC 需要注意的几个**问题：**  允许空回滚，防悬挂控制，幂等设计

###### AT

AT 模式就是两阶段提交，自动生成反向SQL

###### 柔性事务下隔离级别 

特性

- 原子性（Atomicity）：正常情况下保证。

- 一致性（Consistency）：在某个时间点，会出现A库和B库的数据违反一致性要求的情况，但是最终是一 致的。
- 隔离性（Isolation）：在某个时间点，A事务能够读到B事务部分提交的结果。 

- 持久性（Durability），和本地事务一样，只要commit则数据被持久。 

隔离级别：一般情况下都是**读已提交（全局锁）**、**读未提交（无全局锁）**。

### 总结图

<img src="" style="zoom:50%" />